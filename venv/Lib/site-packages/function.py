# -*- coding: utf-8 -*-
"""
Created on Fri Apr 12 14:00:45 2019

@author: z0040h8s
"""
import cv2
import numpy as np
from skimage.filters import sobel
from skimage.measure import regionprops, label


#function to view the image
def viewImage(image):
    cv2.namedWindow('Image',cv2.WINDOW_NORMAL)
    cv2.imshow('Image',image)
    cv2.waitKey(0)

# function to manually select the ROI (not used anymore)
def selectROI(img_path):
    temp = cv2.imread(img_path)
    cv2.namedWindow("Image",cv2.WINDOW_NORMAL)
    roi = cv2.selectROIs("Image", temp , fromCenter=False, showCrosshair=False)
    cv2.destroyWindow('Image')
    roiLen = np.arange(len(roi))
    roi_part_number = np.insert(roi, roi.shape[1], values=roiLen, axis=1)

    return roi,roi_part_number

# function to extract hotspots
def extractHotspotCluster(img):  # input of the function is the image (in array form)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # change the colorspcae of the image from BGR to RGB
    img_hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)    # change the color space of image from RGB to HSV
    # set the threshold to select the hotspots (red and orange pixels) (it is selected with help of colorspace_graph.py)
    hsv_low = (0,240,120)  # lower threshold
    hsv_high = (25,255,255)  # higher threshold

    hotspot_mask = cv2.inRange(img_hsv, hsv_low, hsv_high)  #create a binary mask using the threshold

    img_hotspot = cv2.bitwise_and(img, img, mask=hotspot_mask) #use the binary mask to extact only the hotspots from the image

    return(hotspot_mask,img_hotspot) # output of the function is the binary mask and the hotspots

# function to extract the coldspots
# since the background color is same as the coldspots color, we first have to
# extract the parts or remove the background
# after the parts are extarcted, the procedure is same as that of hotspot extarction
def extractColdspotCluster(img): # input of the function is the image (in array form)
    img_new_ = adjContrastBrightness(img,0.5,0)  # adjust the contrast and brightness to remove the laser exposure
    img_new = cv2.cvtColor(img_new_, cv2.COLOR_BGR2GRAY) # chnage the colorspcae of the image from BGR to gray
    img_gray = cv2.cvtColor(img_new_, cv2.COLOR_BGR2GRAY)  # chnage the color space of image from RGB to gray
    elevation_map = sobel(img_new)  # create an elevatio map of the parts using sobel function of skimage package

    markers = np.zeros_like(elevation_map) # create a black image with identical size of the originl image
    markers[img_gray < 50] = 255  # set the gray pixels to white pixel and copy to the new image
    markers[img_gray > 150] = 0 # set other pixel to black pixel and copy to the new image
    markers_ = markers.astype('uint8')  # chnage the integer type so that it can be read by opeCV
    markers_new = cv2.bitwise_not(markers_) # invert the image, output will be the skelton of the parts

    contours_1,_ = cv2.findContours(markers_new, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) # find the contour around the image
    mask = np.zeros((img.shape[0],img.shape[1]),np.uint8) # create a mask of the image with the contour

    cv2.fillPoly(mask, contours_1, 255)   # fill the contour so as to get a solid part instead of just teh background
    img_parts = cv2.bitwise_and(img, img, mask=mask)  # use 'and' operator to extarct  the parts from the mask
    img_rgb = cv2.cvtColor(img_parts, cv2.COLOR_BGR2RGB) # change the colorspcae of the image from BGR to RGB
    img_hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)     # change the color space of image from RGB to HSV
     # set the threshold to select the coldspots (blue pixels) (it is selected with help of colorspace_graph.py)
    #hsv_low = (115,240,120) # lower threshold based on gaurva methods
    #hsv_low = (91,100,100) # lower threshold based on Li methods
    #hsv_high = (255,255,255) # higher threshold based on Li methods

    hsv_low = (103,245,215) # lower threshold based on gaurva methods
    #hsv_low = (91,100,100) # lower threshold based on Li methods
    hsv_high = (123,265,295) # higher threshold based on Li methods



    coldspot_mask = cv2.inRange(img_hsv, hsv_low, hsv_high)  #create a binary mask using the threshold

    img_coldspot = cv2.bitwise_and(img, img, mask=coldspot_mask) #use the binary mask to extact only the coldspots from the image

    return(coldspot_mask,img_coldspot) # output of the function is the binary mask and the coldspots

# function to adjust the brightness and the contrast
def adjContrastBrightness(image, contrast, brightness): # input is the image, contras, brightness
    new_image = cv2.convertScaleAbs(image, alpha=contrast, beta=brightness)
    '''
    alpha 1  beta 0      --> no change 
    0 < alpha < 1        --> lower contrast  
    alpha > 1            --> higher contrast
    -127 < beta < +127   --> good range for brightness values
    '''
    return new_image # output is the new modified image

# this function is not used
def findBinary(path):
    img = cv2.imread(path)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img_new = adjContrastBrightness(img_gray,2.8,0)
    elevation_map = sobel(img_new)
    markers = np.zeros_like(elevation_map)
    markers[img_gray < 50] = 255
    markers[img_gray > 150] = 0
    markers_ = markers.astype('uint8')
    markers_new = cv2.bitwise_not(markers_)
    contours_1,_ = cv2.findContours(markers_new, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    mask = np.zeros((img.shape[0],img.shape[1]),np.uint8)
    cv2.fillPoly(mask, contours_1, 255)

    return mask


# find the region of interest of the parts from a series of images
# it add up all the binary images together to a single image
# and then draw the bounding box around the parts
# this is the ROI of the part
def findROI(image_paths): # input is an list of images with their paths
    # initialize different variables
    roi = None
    roi_part_number = None
    roi_part = []
    all_parts = np.zeros((2000,2000),'uint8') # create an empty image, all the other images will be added to it
    for path in image_paths: # loop through all the images
        img = findBinary(path) # find binary of the image
        all_parts = cv2.add(all_parts,img) # add the image to previously defined empty image

    #this section is used to denoise the image i.e. to remove the small parts
    part_denoised = np.zeros_like(all_parts)
    labels = label(all_parts) # specify a label to the parts using the label function

    # select only those parts whode area is greater than 500 px
    for R in regionprops(labels):
        if R.area > 500:
            for c in R.coords:
                part_denoised[c[0], c[1]] = 255

    contours_,_ = cv2.findContours(part_denoised, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) # draw the contouraround the parts

    for cnts in contours_: # loop through all the parts
        x,y,w,h = cv2.boundingRect(cnts)  # draw a bounding box around the parts. output is in form of x,y,w,h
        roi_part.append([x,y,w,h])  # save it in  a variable defined above
        roi = np.asarray(roi_part)  # convert it into array
        roiLen = np.arange(len(roi)) # find the number of bounding boxes in the array, this will be the part number
        roi_part_number = np.insert(roi, roi.shape[1], values=roiLen, axis=1)  # save both the information to a new array

    return roi, roi_part_number # output is roi location and roi location along with the part number

# function to find the part contour in an image
def find_contours(image): # input of the function is the image (in array form)
    img_gray=cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # change the colospace from BGR to gray
    blur = cv2.GaussianBlur(img_gray,(5,5),0) #blurr the image
    blur_adj = adjContrastBrightness(blur,2.8,0) # adjust the contract and the brightness

    elevation_map = sobel(blur_adj)  # create an elevatio map of the parts using sobel function of skimage package

    markers = np.zeros_like(elevation_map) # create a black image with identical size of the originl image
    markers[img_gray < 50] = 255 # set the gray pixels to white pixel and copy to the new image
    markers[img_gray > 150] = 0 # set other pixel to black pixel and copy to the new image

    markers_ = markers.astype('uint8') # chnage the integer type so that it can be read by opeCV
    markers_new = cv2.bitwise_not(markers_) # invert the image, output will be the skelton of the parts

    contours_1,_ = cv2.findContours(markers_new, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) # find the contour around the image

    mask = np.zeros((image.shape[0],image.shape[1]),np.uint8) # create a mask of the image with the contour
    cv2.fillPoly(mask, contours_1, 255) # fill the contour so as to get a solid part instead of just teh background

    contours_2,_ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) # again find the conrours around the part

    # loop through each contour and smooth it using approxPolyDP
    # the smoothness can be changed by changing the factor of the elipson variable
    external_contours = []
    for c1 in contours_2:
        epsilon = 0.002*cv2.arcLength(c1,True)
        approx = cv2.approxPolyDP(c1, epsilon,True)
        external_contours.append(approx)

    return external_contours # output is the smooth contour

# function to sort the contours left to right
def sort_contours(cnts):
    if cnts is None:
        pass
    else:
        # construct the list of bounding boxes and sort them from top to bottom
        boundingBoxes = [cv2.boundingRect(c) for c in cnts]
        (cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),
                                    key=lambda b:b[1][0], reverse=False))
        # return the list of sorted contours and bounding boxes
        return (cnts, boundingBoxes)


# function to check is a point lies in a rectangle or not
# used to find the location of hotspot/coldspot in part number
def rectContains(rect,pt):
    logic = rect[0] < pt[0] < rect[0]+rect[2] and rect[1] < pt[1] < rect[1]+rect[3]
    return logic



